---
layout: post
title: SVN目录非代码文件无感知替换方案
date: 2016-11-30 15:20:48
tags: 
- 工匠图谱
---

## 背景

因为一些**不可控因素**，目前所在的iOS团队依旧使用SVN进行版本管理。

因为项目比较大，架构组在工程设计上将多个业务拆分成独立的`project`,通过一个公用`shell`引入各个业务的`.a静态库`实现组件化解耦，客观条件上造成`branch`的文件非常大，并且因为各业务迭代的进行，静态库经常需要update。

SVN服务器物理地址是在北京研发中心，而我所在的深圳研发中心因为外网带宽限制的问题，常会导致浪费大量时间在等待update上。

在此之前对SVN管理方式一无所知，仅知道同等情况下在git上可以通过切换源可以解决问题。

<!-- more -->

## SVN结构分析

了解到SVN是以在`Working Copy根地址`建立`.svn`隐藏目录来进行信息管理。所以第一件事情是打开这个目录一探究竟。

Mac上显示所有隐藏文件的方法:

```bash
$ defaults write com.apple.finder AppleShowAllFiles -bool true
```

运行该命令后，记得强制重启Finder。

打开之后.svn之后可以看到如下目录树：

```
.svn
├── entries
├── format
├── pristine
├── tmp
└── wc.db
```

这里我们只要重点关注`pristine`及`wc.db`。

- **pristine:**保存当前`Working Copy`下所有文件的各版本变更信息。
- **wc.db:**存储当前`Working Copy`下**当前**所有文件状态的数据库。

也就是说，我们只需要在pristine及wc.db对我们需要手动替换的文件**动动手脚**就行了。

## 基本思路
我们假设北京的服务器为A，我自己的Mac设备为C。

那么当我从A直接update code到C时因为外网带宽限制问题导致时间过长时，首要的是解决带宽的问题。

通过努力，我向公司申请到了一台作为iOS持续集成的Mac Mini（后面我们称之为B）的权限，因为该设备同处深圳内网，没有带宽限制，那一切就好办了。

**基本想法是：**

- 服务器B不间断执行`update`从服务器A更新保证代码最新（低速）
- 设备C需要update library时仅从服务器B`replace`（高速）

## 执行方法
### 1.架设中转服务器

首先ssh到服务器B，然后执行`svn checkout`。

而后编写一个自动定期执行svn update的脚本。

> 关于Mac定时自动执行脚本的方法，在鹅厂实习时候经常用到的有两种：
> 1.crontab
> 2.launchctl

但B设备是一台服务器，脚本一旦执行一般情况下无需去停止它。那么直接使用死循环配合`sleep`可以免去一堆配置的需要。

```bash
for (( i = 0;; i++ )); do
		
		#需要更新
		echo "正在获取更新,请勿中途停止 " $(date '+%Y-%m-%d %H:%M:%S');
		svn update
		wait
		echo "更新完成" $(date '+%Y-%m-%d %H:%M:%S');
		echo "亲,让服务器休息一小会儿(1分钟)"
		sleep 30;

done
```
同时，我们需要开启服务器B的FTP功能，Mac上只需要在`共享设置`上勾选`文件共享`即可。
### 2.执行拷贝替换本地静态库
```bash
localUrl='/Users/Smallfan/Desktop/trunk'

remoteHost='服务器IP'
remoteName='用户名'
remotePasswd='密码'
remotePath='Working Copy目录地址'

cd $localUrl
#从云服务器拷贝替换本地Library
scp -r "$remoteName@$remoteHost:$remotePath/Library" $localUrl
# wget -P . -m -nH ftp://$remoteHost:21/$remotePath/Library --ftp-user=$remoteName --ftp-password=$remotePasswd;
wait
```

wget支持断点续传，理论上功能更强。<br/>
使用需要先安装wget，推荐安装方法：brew

brew安装方法：

```bash
$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```

wget brew安装方法：

```bash
$ brew install wget --with-libressl
```

<br/>

**ok，这样我们就完成了指定文件的替换，大功告成！**

但是如果此时执行`svn update`，一定会发生**冲突**。<br/>
原因在于：替换的文件`MD5`变了，但SVN本地数据库暂未更新。

### 3.修改wc.db对应数据

这个时候应该看看wc.db了。

>Mac下打开db文件推荐使用SQLite Professional

![wc.db表结构](http://odxtco6l9.bkt.clouddn.com/image/svnreplace/Table.png?imageView/2/w/400/h/400/q/100) 

遍历了所有的表，基本锁定NODES和PRISTINE这两个表需要修改。

- **NODES:**所有文件的最新版本记录
- **PRISTINE:**文件对应的MD5记录

![NODES表结构](http://odxtco6l9.bkt.clouddn.com/image/svnreplace/Nodes.png?imageView/2/w/800/h/800/q/100) 

![PRISTINE表结构](http://odxtco6l9.bkt.clouddn.com/image/svnreplace/Pristine.png?imageView/2/w/800/h/800/q/100) 

通过对比发现：

- NODES表中的local_relpath为本地文件的相对路径
- NODES表中的checksum为文件的sha1值
- PRISTINE表中的md5_checksum为文件的MD5值

**那么实际上需要做的有几件事：**

1. 将`NODES`表中替换的文件行数据全部取出（我替换的是Library目录）
2. 将`NODES`表取出的数据中`checksum`对应于`PRISTINE`表`checksum`的数据取出并删除
3. 将`NODES`表中替换的文件行数据全部删除
4. 替换从服务器B中下载的wc.db中的`NODES`对应行数据
5. 替换从服务器B中下载的wc.db中的`PRISTINE`对应行数据

我们暂时将本地的wc.db称为**B.db**，将服务器B的wc.db称之为**A.db**。

```bash
#创建临时文件夹
mkdir temp
chmod -R 777 temp
cd temp

#下载云svn数据库,重命名为A.db
ftp -v -n << EOF
	open $remoteHost
	user $remoteName $remotePasswd
	cd $remotePath/.svn
	bin
	get wc.db
	prompt off
	bye
EOF
wait

cp wc.db A.db
wait

#创建本地svn数据库副本,重命名为B.db
cp $localUrl/.svn/wc.db $localUrl/temp
wait
mv wc.db B.db
wait


#开始执行替换
#从B.NODES表中查local_relpath字段中包含"Library/"的行,将结果存入B.TEMP_NODES表,同时删除原来的数据
sqlite3 B.db "create table TEMP_NODES as select * from NODES where local_relpath like 'Library/%';"
sqlite3 B.db "delete from NODES where local_relpath like 'Library/%';"

#将B.PRISTINE中checksum字段存在于B.TEMP_NODES中checksum字段的行中的md5_checksum存入B.PREDEL_PRISTINE
sqlite3 B.db << EOF
create table PREDEL_PRISTINE as select md5_checksum from PRISTINE where checksum in (select checksum from TEMP_NODES);
.exit
EOF

#删除B.PREDEL_PRISTINE表
sqlite3 B.db "drop table PREDEL_PRISTINE;"

#将B.PRISTINE中checksum字段存在于B.TEMP_NODES中checksum字段的行删除,然后删除B.TEMP_NODES表
sqlite3 B.db "delete from PRISTINE where checksum in (select checksum from TEMP_NODES);"
sqlite3 B.db "drop table TEMP_NODES;"

#从A.NODES查local_relpath字段中包含"Library/"的行,将结果存入A.TEMP2_NODES,然后跨库复制A.TEMP2_NODES到B.TEMP2_NODES
sqlite3 A.db "create table TEMP2_NODES as select * from NODES where local_relpath like 'Library/%';"

sqlite3 B.db << EOF
attach database 'A.db' as 'A';
create table TEMP2_NODES as select * from A.TEMP2_NODES;
.exit
EOF

#将B.TEMP2_NODES插入到B.NODES
sqlite3 B.db "insert into NODES(wc_id,local_relpath,op_depth,parent_relpath,repos_id,repos_path,revision,presence,moved_here,moved_to,kind,properties,depth,checksum,symlink_target,changed_revision,changed_date,changed_author,translated_size,last_mod_time,dav_cache,file_external) select wc_id,local_relpath,op_depth,parent_relpath,repos_id,repos_path,revision,presence,moved_here,moved_to,kind,properties,depth,checksum,symlink_target,changed_revision,changed_date,changed_author,translated_size,last_mod_time,dav_cache,file_external from TEMP2_NODES;"
# sqlite3 B.db "insert into NODES select * from TEMP2_NODES;"

#将B.TEMP2_NODES中checksum所有数据导出到文件BPREMERGELIST.txt
sqlite3 B.db "select checksum from TEMP2_NODES;" > BPREMERGELIST.txt
wait

#删除B.TEMP2_NODES表
sqlite3 B.db "drop table TEMP2_NODES;"






#将A.PRISTINE中checksum字段存在于A.TEMP2_NODES中checksum字段的行复制到B.TEMP_PRISTINE
sqlite3 A.db "create table TEMP_PRISTINE as select * from PRISTINE where checksum in (select checksum from TEMP2_NODES);"

sqlite3 B.db << EOF
attach database "A.db" as 'A';
create table TEMP_PRISTINE as select * from A.TEMP_PRISTINE;
.exit
EOF

#将B.TEMP_PRISTINE插入B.PRISTINE
sqlite3 B.db "insert into PRISTINE select * from TEMP_PRISTINE;"

#删除B.TEMP_PRISTINE
sqlite3 B.db "drop table TEMP_PRISTINE;"
#结束替换

```

**完成数据库更新之后，此时千万别执行svn的任何操作！**<br/>
**否则将导致本地svn被破坏！**

因为还差了一步：替换pristine目录下对应文件的修改记录。

### 4.修改pristine目录下文件修改记录

打开pristine目录会看到有非常多以十六进制命名的子目录<br/>
稍微观察会发现：这些子目录的标题对应其目录内文件标题的开头，而这些目录内文件都是以`.svn-base`扩展类型。

这些`svn-base`文件实质上是每个文件每一次提交的变更记录，当在svn中使用`compare`指令时实际上就是使用这些文件，而这些文件的生成时机是每一次文件修改时间被变更时。

所以理论上我们需要替换这里面对应我们替换的文件的记录，替换的源来自服务器B上`.svn`对应`pristine`中的记录。

#### 那么如何获取需要替换的记录呢？

回首刚才的shell脚本里会发现：

```bash
sqlite3 B.db "select checksum from TEMP2_NODES;" > BPREMERGELIST.txt
```

实际上已经将需要替换的数据行重定向到了`BPREMERGELIST.txt`

`checksum`实际上就是`pristine`中所有`.svn-base`命名的组成部分。

#### 举个栗子：
取某一个文件`NODES`中`checksum`的值如下：
`$sha1$0a3c1f7f173dd30dce3cce3e436fd8d8d2a90167`

在`pristine`中找到`0a`的目录，<br/>
打开后Find`pristine`命名为`0a3c1f7f173dd30dce3cce3e436fd8d8d2a90167`的文件。

发现规律了没？

**实际上我们仅需要找到替换的文件对应`NODES`表中的`checksum`字段的sha1值，截取并找到`pristine`下对应的目录及`.svn-base`文件即可**

```bash
#从云服务器找到存在于BREMERGELIST.txt每一行的文件下载至本地.svn/pristine对应路径中
for line in $(cat BPREMERGELIST.txt); do
	if [[ $line == \$sha1* ]]; then
		line=${line##*\$};
		prefix=${line:0:2};

		result=0;
		zero=0;

		all=`ls $localUrl/.svn/pristine`;
		for dir in $all; do
			if [[ $dir == $prefix ]]; then
				result=1;
				break 1;
			fi
		done

		if [ "$result" -eq "$zero" ]; then
			cd pristine;
			mkdir $dir;
			chmod -R 777 $dir;
			wait;
		fi

		cd $localUrl/.svn/pristine/$dir/

		rm -rf ./$line.svn-base
   		wget ftp://$remoteHost:21/$remotePath/.svn/pristine/$dir/$line.svn-base --ftp-user=$remoteName --ftp-password=$remotePasswd;
   		
		wait

	fi
done
```

到这里基本就完成了。

## 注意事项

- **所有操作前务必备份数据（包括整个Working Copy、.svn目录中的wc.db及pristine目录），任何干预svn的操作都是极具风险的！**
- **此方案为个人尝试，因使用造成的任何意外损失概不能负责！**

## 关于自动化脚本

文中提及的脚本内容，我已经整合成shell脚本文件，放在了我的github上，地址如下:

### [Github:Replace-SVN-local-doc](https://github.com/Smallfan/Replace-SVN-local-doc)

## 最后

后来和架构师们一起沟通后，有了更完美的解决方案：

- 使用Jenkins持续集成环境配合服务器B进行自动化生成静态库，这样所有的静态库文件就在近场服务器上，速度慢的问题就解决了。

当然，自己还发现了另一种办法：

- 利用在服务器B上搭建SVN镜像服务器来实现高速update

---------
