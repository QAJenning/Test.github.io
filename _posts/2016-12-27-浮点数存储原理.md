---
layout: post
title: 浮点数存储原理
date: 2016-12-27 09:39:22
tags:
- 工匠图谱
---

## 浮点数存储方式

在以0和1为基础的计算机中，浮点数同样采用二进制的形式存储。一般情况下，32位计算机中`float`占用32位，`double`占用64位。

无论是`float`还是`double`在存储中都分为三个部分：
**符号位(Sign) :** 0代表正，1代表为负。
**指数位（Exponent）:**用于存储科学计数法中的指数数据，并且采用移位存储。
**尾数部分（Mantissa）：**尾数部分。

<!-- more -->

## IEEE754标准规范

**IEEE754规范** 明确了浮点数在计算机中的存储方式，其中**R32.24**和**R64.53**分别针对`float`及`double`。

**R32.24：**即32位内存中，从右到左，第0-22位为`尾数部分`，第23-30位为`指数位`，第31位为`符号位`。
**R64.53：**即64位内存中，从右到左，第0-51位为`尾数部分`，第52-62位为`指数位`，第63位为`符号位`。

这里**R32.24**及**R64.53**为什么分别是24和53，下面会作解释。

**R32.24**和**R64.53**的存储方式都是用科学计数法来存储数据的，比如10.25用二进制表示为1010.01，科学计数法表示为1.01001x2^3。任何非0浮点数都可以表示为1.XXXXx2^n，1.XXXX即为`尾数部分`。因为第一位总会是1，为节省空间计算机不将其存储，在做浮点数运算时再由寄存器将其插入，所以实际存储在尾数部分的为XXXX（小数）部分。而指数部分的n，同样采用二进制形式，存储在`指数位`。

因为**R32.24**中尾数部分存储在第0-22位，那么实际上存储的尾数为23。但因为尾数部分第一个数字1被省略，所以实际存储尾数位数为24位，这就是**R32.24**中24的由来。同理，**R64.53**实际上存储尾数位数为53位。

## 特殊的指数位(阶码)

无论**R32.24**还是**R64.53**，实际上采用的是分段存储机制。每段对应采用二进制形式。

但在`指数位`中，存储的策略不同于`符号位`及`尾数部分`。因为指数为`无符号整数`，但在实际的科学计数法中指数可正可负，故采用**移码**方法表示，对两个指数大小的比较和对阶操作都比较方便，因为阶码域值大者其指数值也大。将浮点数的指数真值 e 变成阶码 Ｅ 时，应将指数 e 加上一个固定的偏移值127(01111111)，即 Ｅ＝e＋127。

> 关于移码：详见 [https://zh.wikipedia.org/wiki/移码](https://zh.wikipedia.org/wiki/移码)

在Wikipedia中介绍：标准**移码**的偏移值为128。而在k位内存存储中浮点数指数位中采用偏移值为(2^(k-1))-1（如**R32.24**中为2^7-1），即为非标准移码。

在IEEE标准中，指数E还可以再分成三种情况：

- E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
- E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
- E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。

以上都是计算机标准约定，
这样在32位浮点数表示中，要除去E用全0和全1(255)表示零和无穷大的特殊情况，指数的偏移值不选128(10000000)，而选127(01111111)。
对于规格化浮点数，E的范围变为1到254，真正的指数值e则为-126到+127。因此32位浮点数表示的绝对值的范围是10^-38 ~ 10^38（以10的幂表示）。


![浮点数存储原理01](http://odxtco6l9.bkt.clouddn.com/image/FloatStorageMode/FloatStorageMode01.jpeg) 

## 课后题
在[ruanyf的博客](http://www.ruanyifeng.com/blog/)中，[《浮点数的二进制表示》](http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)这个文章开篇有一道题目，这里摘取出来，作为典型分析放在最后。

```c
#include <stdio.h>
void main(void){

　　int num=9;
　　float* pFloat=&num;
　　
　　printf("num的值为：%d\n",num);
　　printf("*pFloat的值为：%f\n",*pFloat);
　　
　　*pFloat=9.0;
　　
　　printf("num的值为：%d\n",num);
　　printf("*pFloat的值为：%f\n",*pFloat);
}
```

运行结果如下：

```
num的值为：9
*pFloat的值为：0.000000
num的值为：1091567616
*pFloat的值为：9.000000
```

---------
