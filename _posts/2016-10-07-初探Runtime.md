---
layout: post
title: 初探Runtime - isa & Class
date: 2016-10-07 07:56:48
tags: 
- 牛顿启示录
---

首先先给出两道设计**Runtime**题目，后面会给出解答。

+ 下面代码输出什么?

``` objc
@implementation Szrdc : Firstshare
- (id)init {
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
```

+ 下面代码输出什么?

``` objc
@interface Szrdc : NSObject
@end

@implementation Szrdc
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];
        BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];
        BOOL res3 = [(id)[Szrdc class] isKindOfClass:[Szrdc class]];
        BOOL res4 = [(id)[Szrdc class] isMemberOfClass:[Szrdc class]];

        NSLog(@"%d %d %d %d", res1, res2, res3, res4);
    }
    return 0;
}
```

## 什么是Runtime?
**Runtime **中文称运行时，由iOS/Mac系统底层以C语言函数形式实现的API。

回顾Objective-C这门语言，有如下几个特性：
- **动态类型（Dynamic typing）**：运行时再决定对象的类型。
- **动态绑定（Dynamic binding）**：运行时才确定实际要调用的对象方法。
- **动态加载（Dynamic loading）**：根据需求加载所需要的资源。

**C语言**

在C语言等静态语言中，在编译期，根据代码函数的调用就会决定调用哪个函数。

**Objective-C**

而Objective-C 是一种动态语言，编译阶段只是确定了要向接收者（类或实例）发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。开发者在编码过程中，可以给任意一个对象发送任何消息（只要完成了必要的方法声明，甚至可以是没有具体实现的方法），只有在真正运行时才会根据函数的名称找到对应的函数来调用。

这意味着Objective-C（下面简称为Objc）不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。

Objc 在三种层面上与 Runtime 系统进行交互：
**①Objective-C 源代码**  
**②Foundation 框架下 NSObject 类定义的方法**  
**③对 Runtime 库函数的直接调用**。

![Runtime系统层次图](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/Runtime%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg)

### 通过 Objective-C 源代码
一般情况下，开发者只需要编写 OC 源代码，Runtime 系统会在编译阶段将所有源码转换成运行时代码，在运行时确定对应的数据结构和具体的方法调用。
### 通过 Foundation 框架下 NSObject 类定义的方法
如果你探究过NSObject类的头文件就会发现：NSObject没有父类，换言之就是NSObject是Foundation框架里根类（基类），与此相同的基类还有一个NSProxy类。这两个类都定义了类层次结构中该类下方所有类的公共接口和行为。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。

*iOS10.0 NSObject.h 部分代码*

``` objc
@protocol NSObject
@property (readonly) Class superclass;
- (Class)class OBJC_SWIFT_UNAVAILABLE("use 'anObject.dynamicType' instead");

- (id)performSelector:(SEL)aSelector;
- (id)performSelector:(SEL)aSelector withObject:(id)object;
- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;

- (BOOL)isKindOfClass:(Class)aClass;
- (BOOL)isMemberOfClass:(Class)aClass;
- (BOOL)conformsToProtocol:(Protocol *)aProtocol;

- (BOOL)respondsToSelector:(SEL)aSelector;

- (instancetype)retain OBJC_ARC_UNAVAILABLE;
- (oneway void)release OBJC_ARC_UNAVAILABLE;
- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;
- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;

- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;

@end
```

- **superclass成员变量** : 对象的父类;
- **class方法** : 返回对象的类；（OC和Swift默认不支持）
- **performSelector: withObject: withObject:方法** : 运行时向对象发送SEL和参数消息;

- **isKindOfClass:方法** 和 **isMemberOfClass:方法** : 检查对象是否存在于指定的类的继承体系中（是否是其子类或者父类或者当前类的成员变量）;
- **respondsToSelector:方法** : 检查对象能否响应指定的消息；
- **conformsToProtocol:方法** : 检查对象是否实现了指定协议类的方法；
- **respondsToSelector:方法** : 检查对象能否响应特定消息；

以下方法为MRC产物，具体原理抽空另起篇幅专门讲讲（给自己挖个坑），本文暂不讨论。
- **retain方法** : 持有对象；（ARC下不支持）
- **release方法** : 释放对象；（ARC下不支持）
- **autorelease方法** : 注册对象到autoreleasepool，根据pool生命周期管理对象；（ARC下不支持）
- **retainCount方法** : 返回对象的引用计数；（ARC下不支持）
- **zone方法** : 返回内存分配区域多重管理区块；（ARC下不支持）（系为防止内存碎片化而引入，具体再另起炉灶撰文讨论）

在**NSObject类**还定义了

*iOS10.0 NSObject.h 部分代码*

``` objc
- (IMP)methodForSelector:(SEL)aSelector;
+ (IMP)instanceMethodForSelector:(SEL)aSelector;
```

它们用于返回类或实例中指定方法实现的地址IMP。（[什么是IMP？](http://www.jianshu.com/p/4a09d5ebdc2c)）

### 通过对 Runtime 库函数的直接调用
前面我们提到过：Objc是一门动态语言，也就是说实际上程序在运行时需要一套运行系统和API实时支持，这套API就是Runtime库函数，由C语言函数实现，具备面向对象能力。
关于Runtime 函数可以在Apple官方文档[objective-c runtime reference](https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime)中详细查看。
> **提示** : Apple越来越不建议开发者手动调用Runtime的API，也同样希望开发者不要知道具体底层实现。所以有时候Xcode会出现编写Runtime函数时没有代码提示，解决方式如下：
![Xcode配置](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/Xcode%E9%85%8D%E7%BD%AE.png)

## 浅度剖析NSObject类
NSObject的定义如下：
``` objc
typedef struct objc_class *Class;

@interface NSObject  {
Class isa  OBJC_ISA_AVAILABILITY;
}
```
在Objc2.0之前，**objc_class**源码如下：
``` objc
struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

    #if !__OBJC2__
        Class super_class                                        OBJC2_UNAVAILABLE;
        const char *name                                         OBJC2_UNAVAILABLE;
        long version                                             OBJC2_UNAVAILABLE;
        long info                                                OBJC2_UNAVAILABLE;
        long instance_size                                       OBJC2_UNAVAILABLE;
        struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
        struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
        struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
        struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
    #endif

} OBJC2_UNAVAILABLE;
```
可以看出在Objc2.0之前，一个类中具有超类指针，类名，版本等信息。
**ivars**是objc_ivar_list成员变量列表的指针；**methodLists**是指向objc_method_list指针的指针。 *methodLists是指向方法列表的指针。这里如果动态修改*methodLists的值来添加成员方法，也就是Category实现的原理了，同样解释了Category不能添加属性的原因。
关于Category，抽空另起篇幅好好说说它。（又挖坑？）

Objc 2.0之后，**objc_class**的定义变成如下：
``` objc
typedef struct objc_class *Class;
typedef struct objc_object *id;

@interface Object { 
    Class isa; 
}

@interface NSObject  {
    Class isa  OBJC_ISA_AVAILABILITY;
}

struct objc_object {
    private:
    isa_t isa;
}

struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
}

union isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }
    Class cls;
    uintptr_t bits;
}
```

![objc_class类图](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/objc_class%E7%B1%BB%E5%9B%BE.png)

Objc对象都是 C 语言结构体实现的，在Objc2.0中，所有的对象都会包含一个isa_t类型的结构体。
objc_object被源码typedef成了id类型，这也就是我们平时遇到的id类型。这个结构体中就只包含了一个isa_t类型的结构体。这个结构体在下面会详细分析。
objc_class继承于objc_object。所以在objc_class中也会包含isa_t类型的结构体isa。至此，可以得出结论：Objective-C 中类也是一个对象。在objc_class中，除了isa之外，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法链表。
object类和NSObject类里面分别都包含一个objc_class类型的isa。

**先从isa来说起**

当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。

*这里有个疑问：但是在我们调用类方法的时候，类对象的isa里面是什么呢？*

这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。
>关于元类，更多具体可以研究这篇文章[what is a meta-class in objective-c](http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html)

在引入元类之后，类对象和对象查找方法的机制就完全统一了。

对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。
类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。

meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。

![类与元类关系图](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png)

如上图所示：
**1.** Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。
**2.** 每个Class都有一个isa指针指向唯一的Meta class
**3.** Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。
**4.** 每个Meta class的isa指针都指向Root class (meta)。

类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在main方法执行之前，从 dyld到runtime这期间，类对象和元类对象在这期间被创建。

1. isa_t结构体的具体实现

``` objc
struct objc_object {
    private:
        isa_t isa;
    public:
        void initIsa(Class cls /*indexed=false*/);
        void initInstanceIsa(Class cls, bool hasCxxDtor);
    private:
        void initIsa(Class newCls, bool indexed, bool hasCxxDtor);
｝
```

那就从initIsa方法开始研究。下面以arm64为例。

``` objc
inline void
objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)
{
initIsa(cls, true, hasCxxDtor);
}

inline void
objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)
{
if (!indexed) {
isa.cls = cls;
} else {
isa.bits = ISA_MAGIC_VALUE;
isa.has_cxx_dtor = hasCxxDtor;
isa.shiftcls = (uintptr_t)cls >> 3;
}
}
```

initIsa第二个参数传入了一个true，所以initIsa就会执行else里面的语句。

``` objc
# if __arm64__
#   define ISA_MASK        0x0000000ffffffff8ULL
#   define ISA_MAGIC_MASK  0x000003f000000001ULL
#   define ISA_MAGIC_VALUE 0x000001a000000001ULL
struct {
    uintptr_t indexed           : 1;
    uintptr_t has_assoc         : 1;
    uintptr_t has_cxx_dtor      : 1;
    uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000
    uintptr_t magic             : 6;
    uintptr_t weakly_referenced : 1;
    uintptr_t deallocating      : 1;
    uintptr_t has_sidetable_rc  : 1;
    uintptr_t extra_rc          : 19;
#       define RC_ONE   (1ULL
```

![arm64及x86_64 isa_t 内存对照表](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/isa_t%E7%BB%93%E6%9E%84%E5%9B%BE.jpg)

ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001

![arm64 isa_t实际运行表](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/isa_t%E5%AE%9E%E9%99%85%E8%BF%90%E8%A1%8C%E5%9B%BE.png)

关于参数的说明：
**index**
代表是否开启isa指针优化。index = 1，代表开启isa指针优化。

在2013年9月，苹果推出了iPhone5s，与此同时，iPhone5s配备了首个采用64位架构的A7双核处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。
在WWDC2013的《Session 404 Advanced in Objective-C》视频中，Apple介绍了 Tagged Pointer。 Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。
>关于**Tagged Pointer**，唐巧在[深入理解Tagged Pointer](http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/)更深入地探讨了。

假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。如下图所示：

![](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/%E6%9C%AA%E4%BD%BF%E7%94%A8TaggedPointer.png)

Apple提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了Tagged Pointer对象之后，64位CPU下NSNumber的内存图变成了以下这样：

![](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/%E4%BD%BF%E7%94%A8TaggedPointer.png)

**has_assoc**
对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存

**has_cxx_dtor**
表示该对象是否有 C++ 或者 Objc 的析构器

**shiftcls**
类的指针。arm64架构中有33位可以存储类指针。

源码中isa.shiftcls = (uintptr_t)cls >> 3;
将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看[从NSObject 的初始化了解isa](https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md#shiftcls)的shiftcls分析。

**magic**
判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间。

**weakly_referenced**
对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。

**deallocating**
对象是否正在释放内存。

**has_sidetable_rc**
判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。

**extra_rc**
存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc的值就为 9。

ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。

2. cache_t的具体实现

``` objc
struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;
}

typedef unsigned int uint32_t;
typedef uint32_t mask_t;  // x86_64 & arm64 asm are less efficient with 16-bits

typedef unsigned long  uintptr_t;
typedef uintptr_t cache_key_t;

struct bucket_t {
    private:
        cache_key_t _key;
        IMP _imp;
}
```

![](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/cache_t.png)

- **mask** ：分配用来缓存bucket的总数。
- **occupied** ：表明目前实际占用的缓存bucket的个数。
- **bucket_t** : 存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。

**cache_t**中的bucket_t *_buckets其实就是一个散列表，用来存储Method的链表。

Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。

2. class_data_bits_t的具体实现

``` objc
struct class_data_bits_t {

    // Values are the FAST_ flags above.
    uintptr_t bits;
}

struct class_rw_t {
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;

    char *demangledName;
}

struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    #ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;

    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};
```
![class_data_bits_t](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/class_data_bits_t.png)

在 objc_class结构体中的注释写到 **class_data_bits_t** 相当于 **class_rw_t** 指针加上 **rr/alloc** 的标志。
``` objc
class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags
```
它为我们提供了便捷方法用于返回其中的 class_rw_t *指针：
``` objc
class_rw_t *data() {
    return bits.data();
}
```
Objc的类的属性、方法、以及遵循的协议在obj 2.0的版本之后都放在class_rw_t中。class_ro_t是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。（rw-readwrite，ro-readonly）

**编译期**，类的结构中的 class_data_bits_t *data指向的是一个 class_ro_t *指针：
![](http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/class_data_bits_t2.png)

在运行时调用 realizeClass方法，会做以下3件事情：
**1.**从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针
**2.**初始化一个 class_rw_t结构体
**3.**设置结构体 ro的值以及 flag

最后调用methodizeClass方法，把类里面的属性，协议，方法都加载进来。
``` objc
struct method_t {
    SEL name;
    const char *types;
    IMP imp;

struct SortBySELAddress :
    public std::binary_function
    {
        bool operator() (const method_t& lhs,
        const method_t& rhs)
    { return lhs.name 
```
方法method的定义如上。里面包含3个成员变量。SEL是方法的名字name。types是[Type Encoding](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)类型编码。
IMP是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。

## 题目解析

截止到这里，前面两道题我们可以来试着分析。
>题目一：下面代码输出什么?
``` objc
@implementation Szrdc : Firstshare
- (id)init {
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
```

**分析**
**self**是类的一个隐藏参数，每个方法的实现的第一个参数即为self。
**super**并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，去调用父类的方法，而不是本类中的方法。

在调用[super class]的时候，runtime会去调用objc_msgSendSuper方法，而不是objc_msgSend。

``` objc
OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )


/// Specifies the superclass of an instance. 
struct objc_super {
/// Specifies an instance of a class.
__unsafe_unretained id receiver;

/// Specifies the particular superclass of the instance to message. 
#if !defined(__cplusplus)  &&  !__OBJC2__
/* For compatibility with old objc-runtime.h header */
__unsafe_unretained Class class;
#else
__unsafe_unretained Class super_class;
#endif
/* super_class is the first class to search */
};
```

在objc_msgSendSuper方法中，第一个参数是一个objc_super的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类super_class。

**objc_msgSendSuper**的工作原理:
从objc_super结构体指向的superClass父类的方法列表开始查找selector，找到后以objc->receiver去调用这个selector。注意，最后的调用者是objc->receiver，而不是super_class！

那么objc_msgSendSuper最后就转变成：
``` objc
objc_msgSend(objc_super->receiver, @selector(class))
```
**答案**
**objc_super->receiver = self。所以最后输出两个都一样，都是输出son。**
<br />
>题目二：下面代码输出什么?
``` objc
@interface Szrdc : NSObject
@end
@implementation Szrdc
@end
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];
        BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];
        BOOL res3 = [(id)[Szrdc class] isKindOfClass:[Szrdc class]];
        BOOL res4 = [(id)[Szrdc class] isMemberOfClass:[Szrdc class]];
        NSLog(@"%d %d %d %d", res1, res2, res3, res4);
    }
    return 0;
}
```

**分析**
以下是NSObject协议几个方法的具体实现（OpenSource）：

``` objc
+ (Class)class {
    return self;
}

- (Class)class {
    return object_getClass(self);
}

Class object_getClass(id obj)
{
    if (obj) return obj->getIsa();
    else return Nil;
}

inline Class 
objc_object::getIsa() 
{
    if (isTaggedPointer()) {
        uintptr_t slot = ((uintptr_t)this >> TAG_SLOT_SHIFT) & TAG_SLOT_MASK;
        return objc_tag_classes[slot];
    }
    return ISA();
}

inline Class 
objc_object::ISA() 
{
    assert(!isTaggedPointer()); 
    return (Class)(isa.bits & ISA_MASK);
}

+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls->superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

+ (BOOL)isMemberOfClass:(Class)cls {
    return object_getClass((id)self) == cls;
}

- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}
```

isKindOfClass:方法内部，会先去获得object_getClass的类，而object_getClass的源码实现是去调用当前类的obj->getIsa()，最后在ISA()方法中获得meta class的指针。

接着在isKindOfClass中有一个循环，先判断class是否等于meta class，不等就继续循环判断是否等于super class，不等再继续取super class，如此循环下去。

[NSObject class]执行完之后调用isKindOfClass，第一次判断先判断NSObject 和 NSObject的meta class是否相等，之前讲到meta class的时候放了一张很详细的图，从图上我们也可以看出，NSObject的meta class与本身不等。接着第二次循环判断NSObject与meta class的superclass是否相等。还是从那张图上面我们可以看到：Root class(meta) 的superclass 就是 Root class(class)，也就是NSObject本身。所以第二次循环相等，于是第一行res1输出应该为YES。

同理，[Szrdc class]执行完之后调用isKindOfClass，第一次for循环，Szrdc的Meta Class与[Szrdc class]不等，第二次for循环，Szrdc Meta Class的super class 指向的是 NSObject Meta Class， 和 Szrdc Class不相等。第三次for循环，NSObject Meta Class的super class指向的是NSObject Class，和 Szrdc Class 不相等。第四次循环，NSObject Class 的super class 指向 nil， 和 Szrdc Class不相等。第四次循环之后，退出循环，所以第三行的res3输出为NO。

如果把这里的Szrdc改成它的实例对象，[szrdc isKindOfClass:[Szrdc class]，那么此时就应该输出YES了。因为在isKindOfClass函数中，判断szrdc的meta class是自己的元类Szrdc，第一次for循环就能输出YES了。

isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。
第二行isa 指向 NSObject 的 Meta Class，所以和 NSObject Class不相等。第四行，isa指向Szrdc的Meta Class，和Szrdc Class也不等，所以第二行res2和第四行res4都输出NO。
**答案**
**1 0 0 0**

---------
