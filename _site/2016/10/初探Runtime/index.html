<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>初探Runtime - isa &amp; Class</title>
  <meta name="description" content="首先先给出两道设计Runtime题目，后面会给出解答。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="初探Runtime - isa &amp; Class">
  <meta name="twitter:description" content="首先先给出两道设计Runtime题目，后面会给出解答。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="初探Runtime - isa &amp; Class">
  <meta property="og:description" content="首先先给出两道设计Runtime题目，后面会给出解答。">
  
  <link rel="icon" type="image/ico" href="/assets/images/favicon.ico" />
  <link href="/assets/images/favicon.ico" rel="shortcut icon" type="image/ico">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2016/10/%E5%88%9D%E6%8E%A2Runtime/">
  <link rel="alternate" type="application/rss+xml" title="Ford" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('http://odxtco6l9.bkt.clouddn.com/image/blog/index/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Ford 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Ford logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Ford" class="blog-button">Ford</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">天籁之音，人生几得。</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨！我叫肖帆（@Ford），一名普通的iOS开发者。生活在碧海蓝天下的深圳。以技术和音乐为乐，乐于分享所见所得，请多多指教。</p>
        <!-- <hr class="panel-cover__divider panel-cover__divider--secondary" /> -->
        
        <!-- 
        <p class="panel-cover__description"><a href="https://github.com/onevcat/vno-jekyll" target="_blank">Download the theme</a></p>
         -->
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/CoderSmallfan" title="@CoderSmallfan 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:CoderSmallfan@qq.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-10-07 15:56:48 +0800" itemprop="datePublished" class="post-meta__date date">2016-10-07</time> &#8226; <span class="post-meta__tags tags">牛顿启示录</span>
    </div>
    <h1 class="post-title">初探Runtime - isa & Class</h1>
  </header>

  <section class="post">
    <p>首先先给出两道设计<strong>Runtime</strong>题目，后面会给出解答。</p>

<ul>
  <li>下面代码输出什么?</li>
</ul>

<pre><code class="language-objc">@implementation Szrdc : Firstshare
- (id)init {
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre>

<ul>
  <li>下面代码输出什么?</li>
</ul>

<pre><code class="language-objc">@interface Szrdc : NSObject
@end

@implementation Szrdc
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];
        BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];
        BOOL res3 = [(id)[Szrdc class] isKindOfClass:[Szrdc class]];
        BOOL res4 = [(id)[Szrdc class] isMemberOfClass:[Szrdc class]];

        NSLog(@"%d %d %d %d", res1, res2, res3, res4);
    }
    return 0;
}
</code></pre>

<h2 id="什么是runtime">什么是Runtime?</h2>
<p>**Runtime **中文称运行时，由iOS/Mac系统底层以C语言函数形式实现的API。</p>

<p>回顾Objective-C这门语言，有如下几个特性：</p>
<ul>
  <li><strong>动态类型（Dynamic typing）</strong>：运行时再决定对象的类型。</li>
  <li><strong>动态绑定（Dynamic binding）</strong>：运行时才确定实际要调用的对象方法。</li>
  <li><strong>动态加载（Dynamic loading）</strong>：根据需求加载所需要的资源。</li>
</ul>

<p><strong>C语言</strong></p>

<p>在C语言等静态语言中，在编译期，根据代码函数的调用就会决定调用哪个函数。</p>

<p><strong>Objective-C</strong></p>

<p>而Objective-C 是一种动态语言，编译阶段只是确定了要向接收者（类或实例）发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。开发者在编码过程中，可以给任意一个对象发送任何消息（只要完成了必要的方法声明，甚至可以是没有具体实现的方法），只有在真正运行时才会根据函数的名称找到对应的函数来调用。</p>

<p>这意味着Objective-C（下面简称为Objc）不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。</p>

<p>Objc 在三种层面上与 Runtime 系统进行交互：
<strong>①Objective-C 源代码</strong><br />
<strong>②Foundation 框架下 NSObject 类定义的方法</strong><br />
<strong>③对 Runtime 库函数的直接调用</strong>。</p>

<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/Runtime%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="Runtime系统层次图" /></p>

<h3 id="通过-objective-c-源代码">通过 Objective-C 源代码</h3>
<p>一般情况下，开发者只需要编写 OC 源代码，Runtime 系统会在编译阶段将所有源码转换成运行时代码，在运行时确定对应的数据结构和具体的方法调用。</p>
<h3 id="通过-foundation-框架下-nsobject-类定义的方法">通过 Foundation 框架下 NSObject 类定义的方法</h3>
<p>如果你探究过NSObject类的头文件就会发现：NSObject没有父类，换言之就是NSObject是Foundation框架里根类（基类），与此相同的基类还有一个NSProxy类。这两个类都定义了类层次结构中该类下方所有类的公共接口和行为。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。</p>

<p><em>iOS10.0 NSObject.h 部分代码</em></p>

<pre><code class="language-objc">@protocol NSObject
@property (readonly) Class superclass;
- (Class)class OBJC_SWIFT_UNAVAILABLE("use 'anObject.dynamicType' instead");

- (id)performSelector:(SEL)aSelector;
- (id)performSelector:(SEL)aSelector withObject:(id)object;
- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;

- (BOOL)isKindOfClass:(Class)aClass;
- (BOOL)isMemberOfClass:(Class)aClass;
- (BOOL)conformsToProtocol:(Protocol *)aProtocol;

- (BOOL)respondsToSelector:(SEL)aSelector;

- (instancetype)retain OBJC_ARC_UNAVAILABLE;
- (oneway void)release OBJC_ARC_UNAVAILABLE;
- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;
- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;

- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;

@end
</code></pre>

<ul>
  <li><strong>superclass成员变量</strong> : 对象的父类;</li>
  <li><strong>class方法</strong> : 返回对象的类；（OC和Swift默认不支持）</li>
  <li>
    <p><strong>performSelector: withObject: withObject:方法</strong> : 运行时向对象发送SEL和参数消息;</p>
  </li>
  <li><strong>isKindOfClass:方法</strong> 和 <strong>isMemberOfClass:方法</strong> : 检查对象是否存在于指定的类的继承体系中（是否是其子类或者父类或者当前类的成员变量）;</li>
  <li><strong>respondsToSelector:方法</strong> : 检查对象能否响应指定的消息；</li>
  <li><strong>conformsToProtocol:方法</strong> : 检查对象是否实现了指定协议类的方法；</li>
  <li><strong>respondsToSelector:方法</strong> : 检查对象能否响应特定消息；</li>
</ul>

<p>以下方法为MRC产物，具体原理抽空另起篇幅专门讲讲（给自己挖个坑），本文暂不讨论。</p>
<ul>
  <li><strong>retain方法</strong> : 持有对象；（ARC下不支持）</li>
  <li><strong>release方法</strong> : 释放对象；（ARC下不支持）</li>
  <li><strong>autorelease方法</strong> : 注册对象到autoreleasepool，根据pool生命周期管理对象；（ARC下不支持）</li>
  <li><strong>retainCount方法</strong> : 返回对象的引用计数；（ARC下不支持）</li>
  <li><strong>zone方法</strong> : 返回内存分配区域多重管理区块；（ARC下不支持）（系为防止内存碎片化而引入，具体再另起炉灶撰文讨论）</li>
</ul>

<p>在<strong>NSObject类</strong>还定义了</p>

<p><em>iOS10.0 NSObject.h 部分代码</em></p>

<pre><code class="language-objc">- (IMP)methodForSelector:(SEL)aSelector;
+ (IMP)instanceMethodForSelector:(SEL)aSelector;
</code></pre>

<p>它们用于返回类或实例中指定方法实现的地址IMP。（<a href="http://www.jianshu.com/p/4a09d5ebdc2c">什么是IMP？</a>）</p>

<h3 id="通过对-runtime-库函数的直接调用">通过对 Runtime 库函数的直接调用</h3>
<p>前面我们提到过：Objc是一门动态语言，也就是说实际上程序在运行时需要一套运行系统和API实时支持，这套API就是Runtime库函数，由C语言函数实现，具备面向对象能力。
关于Runtime 函数可以在Apple官方文档<a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime">objective-c runtime reference</a>中详细查看。</p>
<blockquote>
  <p><strong>提示</strong> : Apple越来越不建议开发者手动调用Runtime的API，也同样希望开发者不要知道具体底层实现。所以有时候Xcode会出现编写Runtime函数时没有代码提示，解决方式如下：
<img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/Xcode%E9%85%8D%E7%BD%AE.png" alt="Xcode配置" /></p>
</blockquote>

<h2 id="浅度剖析nsobject类">浅度剖析NSObject类</h2>
<p>NSObject的定义如下：</p>
<pre><code class="language-objc">typedef struct objc_class *Class;

@interface NSObject  {
Class isa  OBJC_ISA_AVAILABILITY;
}
</code></pre>
<p>在Objc2.0之前，<strong>objc_class</strong>源码如下：</p>
<pre><code class="language-objc">struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

    #if !__OBJC2__
        Class super_class                                        OBJC2_UNAVAILABLE;
        const char *name                                         OBJC2_UNAVAILABLE;
        long version                                             OBJC2_UNAVAILABLE;
        long info                                                OBJC2_UNAVAILABLE;
        long instance_size                                       OBJC2_UNAVAILABLE;
        struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
        struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
        struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
        struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
    #endif

} OBJC2_UNAVAILABLE;
</code></pre>
<p>可以看出在Objc2.0之前，一个类中具有超类指针，类名，版本等信息。
<strong>ivars</strong>是objc_ivar_list成员变量列表的指针；<strong>methodLists</strong>是指向objc_method_list指针的指针。 <em>methodLists是指向方法列表的指针。这里如果动态修改</em>methodLists的值来添加成员方法，也就是Category实现的原理了，同样解释了Category不能添加属性的原因。
关于Category，抽空另起篇幅好好说说它。（又挖坑？）</p>

<p>Objc 2.0之后，<strong>objc_class</strong>的定义变成如下：</p>
<pre><code class="language-objc">typedef struct objc_class *Class;
typedef struct objc_object *id;

@interface Object { 
    Class isa; 
}

@interface NSObject  {
    Class isa  OBJC_ISA_AVAILABILITY;
}

struct objc_object {
    private:
    isa_t isa;
}

struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
}

union isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }
    Class cls;
    uintptr_t bits;
}
</code></pre>

<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/objc_class%E7%B1%BB%E5%9B%BE.png" alt="objc_class类图" /></p>

<p>Objc对象都是 C 语言结构体实现的，在Objc2.0中，所有的对象都会包含一个isa_t类型的结构体。
objc_object被源码typedef成了id类型，这也就是我们平时遇到的id类型。这个结构体中就只包含了一个isa_t类型的结构体。这个结构体在下面会详细分析。
objc_class继承于objc_object。所以在objc_class中也会包含isa_t类型的结构体isa。至此，可以得出结论：Objective-C 中类也是一个对象。在objc_class中，除了isa之外，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法链表。
object类和NSObject类里面分别都包含一个objc_class类型的isa。</p>

<p><strong>先从isa来说起</strong></p>

<p>当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</p>

<p><em>这里有个疑问：但是在我们调用类方法的时候，类对象的isa里面是什么呢？</em></p>

<p>这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。</p>
<blockquote>
  <p>关于元类，更多具体可以研究这篇文章<a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">what is a meta-class in objective-c</a></p>
</blockquote>

<p>在引入元类之后，类对象和对象查找方法的机制就完全统一了。</p>

<p>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。
类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</p>

<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>

<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="类与元类关系图" /></p>

<p>如上图所示：
<strong>1.</strong> Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。
<strong>2.</strong> 每个Class都有一个isa指针指向唯一的Meta class
<strong>3.</strong> Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。
<strong>4.</strong> 每个Meta class的isa指针都指向Root class (meta)。</p>

<p>类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在main方法执行之前，从 dyld到runtime这期间，类对象和元类对象在这期间被创建。</p>

<ol>
  <li>isa_t结构体的具体实现</li>
</ol>

<pre><code class="language-objc">struct objc_object {
    private:
        isa_t isa;
    public:
        void initIsa(Class cls /*indexed=false*/);
        void initInstanceIsa(Class cls, bool hasCxxDtor);
    private:
        void initIsa(Class newCls, bool indexed, bool hasCxxDtor);
｝
</code></pre>

<p>那就从initIsa方法开始研究。下面以arm64为例。</p>

<pre><code class="language-objc">inline void
objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)
{
initIsa(cls, true, hasCxxDtor);
}

inline void
objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)
{
if (!indexed) {
isa.cls = cls;
} else {
isa.bits = ISA_MAGIC_VALUE;
isa.has_cxx_dtor = hasCxxDtor;
isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;
}
}
</code></pre>

<p>initIsa第二个参数传入了一个true，所以initIsa就会执行else里面的语句。</p>

<pre><code class="language-objc"># if __arm64__
#   define ISA_MASK        0x0000000ffffffff8ULL
#   define ISA_MAGIC_MASK  0x000003f000000001ULL
#   define ISA_MAGIC_VALUE 0x000001a000000001ULL
struct {
    uintptr_t indexed           : 1;
    uintptr_t has_assoc         : 1;
    uintptr_t has_cxx_dtor      : 1;
    uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000
    uintptr_t magic             : 6;
    uintptr_t weakly_referenced : 1;
    uintptr_t deallocating      : 1;
    uintptr_t has_sidetable_rc  : 1;
    uintptr_t extra_rc          : 19;
#       define RC_ONE   (1ULL
</code></pre>

<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/isa_t%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="arm64及x86_64 isa_t 内存对照表" /></p>

<p>ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001</p>

<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/isa_t%E5%AE%9E%E9%99%85%E8%BF%90%E8%A1%8C%E5%9B%BE.png" alt="arm64 isa_t实际运行表" /></p>

<p>关于参数的说明：
<strong>index</strong>
代表是否开启isa指针优化。index = 1，代表开启isa指针优化。</p>

<p>在2013年9月，苹果推出了iPhone5s，与此同时，iPhone5s配备了首个采用64位架构的A7双核处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。
在WWDC2013的《Session 404 Advanced in Objective-C》视频中，Apple介绍了 Tagged Pointer。 Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。</p>
<blockquote>
  <p>关于<strong>Tagged Pointer</strong>，唐巧在<a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/">深入理解Tagged Pointer</a>更深入地探讨了。</p>
</blockquote>

<p>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。如下图所示：</p>

<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/%E6%9C%AA%E4%BD%BF%E7%94%A8TaggedPointer.png" alt="" /></p>

<p>Apple提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了Tagged Pointer对象之后，64位CPU下NSNumber的内存图变成了以下这样：</p>

<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/%E4%BD%BF%E7%94%A8TaggedPointer.png" alt="" /></p>

<p><strong>has_assoc</strong>
对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</p>

<p><strong>has_cxx_dtor</strong>
表示该对象是否有 C++ 或者 Objc 的析构器</p>

<p><strong>shiftcls</strong>
类的指针。arm64架构中有33位可以存储类指针。</p>

<p>源码中isa.shiftcls = (uintptr_t)cls » 3;
将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md#shiftcls">从NSObject 的初始化了解isa</a>的shiftcls分析。</p>

<p><strong>magic</strong>
判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间。</p>

<p><strong>weakly_referenced</strong>
对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。</p>

<p><strong>deallocating</strong>
对象是否正在释放内存。</p>

<p><strong>has_sidetable_rc</strong>
判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。</p>

<p><strong>extra_rc</strong>
存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc的值就为 9。</p>

<p>ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。</p>

<ol>
  <li>cache_t的具体实现</li>
</ol>

<pre><code class="language-objc">struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;
}

typedef unsigned int uint32_t;
typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits

typedef unsigned long  uintptr_t;
typedef uintptr_t cache_key_t;

struct bucket_t {
    private:
        cache_key_t _key;
        IMP _imp;
}
</code></pre>

<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/cache_t.png" alt="" /></p>

<ul>
  <li><strong>mask</strong> ：分配用来缓存bucket的总数。</li>
  <li><strong>occupied</strong> ：表明目前实际占用的缓存bucket的个数。</li>
  <li><strong>bucket_t</strong> : 存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。</li>
</ul>

<p><strong>cache_t</strong>中的bucket_t *_buckets其实就是一个散列表，用来存储Method的链表。</p>

<p>Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p>

<ol>
  <li>class_data_bits_t的具体实现</li>
</ol>

<pre><code class="language-objc">struct class_data_bits_t {

    // Values are the FAST_ flags above.
    uintptr_t bits;
}

struct class_rw_t {
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;

    char *demangledName;
}

struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    #ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;

    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};
</code></pre>
<p><img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/class_data_bits_t.png" alt="class_data_bits_t" /></p>

<p>在 objc_class结构体中的注释写到 <strong>class_data_bits_t</strong> 相当于 <strong>class_rw_t</strong> 指针加上 <strong>rr/alloc</strong> 的标志。</p>
<pre><code class="language-objc">class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags
</code></pre>
<p>它为我们提供了便捷方法用于返回其中的 class_rw_t *指针：</p>
<pre><code class="language-objc">class_rw_t *data() {
    return bits.data();
}
</code></pre>
<p>Objc的类的属性、方法、以及遵循的协议在obj 2.0的版本之后都放在class_rw_t中。class_ro_t是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。（rw-readwrite，ro-readonly）</p>

<p><strong>编译期</strong>，类的结构中的 class_data_bits_t *data指向的是一个 class_ro_t *指针：
<img src="http://odxtco6l9.bkt.clouddn.com/image/chutanruntime/class_data_bits_t2.png" alt="" /></p>

<p>在运行时调用 realizeClass方法，会做以下3件事情：
<strong>1.</strong>从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针
<strong>2.</strong>初始化一个 class_rw_t结构体
<strong>3.</strong>设置结构体 ro的值以及 flag</p>

<p>最后调用methodizeClass方法，把类里面的属性，协议，方法都加载进来。</p>
<pre><code class="language-objc">struct method_t {
    SEL name;
    const char *types;
    IMP imp;

struct SortBySELAddress :
    public std::binary_function
    {
        bool operator() (const method_t&amp; lhs,
        const method_t&amp; rhs)
    { return lhs.name 
</code></pre>
<p>方法method的定义如上。里面包含3个成员变量。SEL是方法的名字name。types是<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encoding</a>类型编码。
IMP是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。</p>

<h2 id="题目解析">题目解析</h2>

<p>截止到这里，前面两道题我们可以来试着分析。</p>
<blockquote>
  <p>题目一：下面代码输出什么?</p>
  <pre><code class="language-objc">@implementation Szrdc : Firstshare
- (id)init {
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre>
</blockquote>

<p><strong>分析</strong>
<strong>self</strong>是类的一个隐藏参数，每个方法的实现的第一个参数即为self。
<strong>super</strong>并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，去调用父类的方法，而不是本类中的方法。</p>

<p>在调用[super class]的时候，runtime会去调用objc_msgSendSuper方法，而不是objc_msgSend。</p>

<pre><code class="language-objc">OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )


/// Specifies the superclass of an instance. 
struct objc_super {
/// Specifies an instance of a class.
__unsafe_unretained id receiver;

/// Specifies the particular superclass of the instance to message. 
#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__
/* For compatibility with old objc-runtime.h header */
__unsafe_unretained Class class;
#else
__unsafe_unretained Class super_class;
#endif
/* super_class is the first class to search */
};
</code></pre>

<p>在objc_msgSendSuper方法中，第一个参数是一个objc_super的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类super_class。</p>

<p><strong>objc_msgSendSuper</strong>的工作原理:
从objc_super结构体指向的superClass父类的方法列表开始查找selector，找到后以objc-&gt;receiver去调用这个selector。注意，最后的调用者是objc-&gt;receiver，而不是super_class！</p>

<p>那么objc_msgSendSuper最后就转变成：</p>
<pre><code class="language-objc">objc_msgSend(objc_super-&gt;receiver, @selector(class))
</code></pre>
<p><strong>答案</strong>
<strong>objc_super-&gt;receiver = self。所以最后输出两个都一样，都是输出son。</strong>
<br /></p>
<blockquote>
  <p>题目二：下面代码输出什么?</p>
  <pre><code class="language-objc">@interface Szrdc : NSObject
@end
@implementation Szrdc
@end
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];
        BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];
        BOOL res3 = [(id)[Szrdc class] isKindOfClass:[Szrdc class]];
        BOOL res4 = [(id)[Szrdc class] isMemberOfClass:[Szrdc class]];
        NSLog(@"%d %d %d %d", res1, res2, res3, res4);
    }
    return 0;
}
</code></pre>
</blockquote>

<p><strong>分析</strong>
以下是NSObject协议几个方法的具体实现（OpenSource）：</p>

<pre><code class="language-objc">+ (Class)class {
    return self;
}

- (Class)class {
    return object_getClass(self);
}

Class object_getClass(id obj)
{
    if (obj) return obj-&gt;getIsa();
    else return Nil;
}

inline Class 
objc_object::getIsa() 
{
    if (isTaggedPointer()) {
        uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK;
        return objc_tag_classes[slot];
    }
    return ISA();
}

inline Class 
objc_object::ISA() 
{
    assert(!isTaggedPointer()); 
    return (Class)(isa.bits &amp; ISA_MASK);
}

+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

+ (BOOL)isMemberOfClass:(Class)cls {
    return object_getClass((id)self) == cls;
}

- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}
</code></pre>

<p>isKindOfClass:方法内部，会先去获得object_getClass的类，而object_getClass的源码实现是去调用当前类的obj-&gt;getIsa()，最后在ISA()方法中获得meta class的指针。</p>

<p>接着在isKindOfClass中有一个循环，先判断class是否等于meta class，不等就继续循环判断是否等于super class，不等再继续取super class，如此循环下去。</p>

<p>[NSObject class]执行完之后调用isKindOfClass，第一次判断先判断NSObject 和 NSObject的meta class是否相等，之前讲到meta class的时候放了一张很详细的图，从图上我们也可以看出，NSObject的meta class与本身不等。接着第二次循环判断NSObject与meta class的superclass是否相等。还是从那张图上面我们可以看到：Root class(meta) 的superclass 就是 Root class(class)，也就是NSObject本身。所以第二次循环相等，于是第一行res1输出应该为YES。</p>

<p>同理，[Szrdc class]执行完之后调用isKindOfClass，第一次for循环，Szrdc的Meta Class与[Szrdc class]不等，第二次for循环，Szrdc Meta Class的super class 指向的是 NSObject Meta Class， 和 Szrdc Class不相等。第三次for循环，NSObject Meta Class的super class指向的是NSObject Class，和 Szrdc Class 不相等。第四次循环，NSObject Class 的super class 指向 nil， 和 Szrdc Class不相等。第四次循环之后，退出循环，所以第三行的res3输出为NO。</p>

<p>如果把这里的Szrdc改成它的实例对象，[szrdc isKindOfClass:[Szrdc class]，那么此时就应该输出YES了。因为在isKindOfClass函数中，判断szrdc的meta class是自己的元类Szrdc，第一次for循环就能输出YES了。</p>

<p>isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。
第二行isa 指向 NSObject 的 Meta Class，所以和 NSObject Class不相等。第四行，isa指向Szrdc的Meta Class，和Szrdc Class也不等，所以第二行res2和第四行res4都输出NO。
<strong>答案</strong>
<strong>1 0 0 0</strong></p>

<hr />

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/11/SVN%E7%9B%AE%E5%BD%95%E9%9D%9E%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E6%97%A0%E6%84%9F%E7%9F%A5%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/" title="link to SVN目录非代码文件无感知替换方案">SVN目录非代码文件无感知替换方案</a></h2>
       <p class="excerpt">背景因为一些不可控因素，目前所在的iOS团队依旧使用SVN进行版本管理。因为项目比较大，架构组在工程设计上将多个业务拆分成独立的project,通过一个公用shell引入各个业务的.a静态库实现组件化解耦，客观条件上造成branch的文件非常大，并且因为各业务迭代的进行，静态库经常需要update。SVN服务器物理地址是在北京研发中心，而我所在的深圳研发中心因为外网带宽限制的问题，常会导致浪费大量时间在等待update上。在此之前对SVN管理方式一无所知，仅知道同等情况下在git上可以通过...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-11-30 23:20:48 +0800" class="post-list__meta--date date">2016-11-30</time> &#8226; <span class="post-list__meta--tags tags">工匠图谱</span><a class="btn-border-small" href=/2016/11/SVN%E7%9B%AE%E5%BD%95%E9%9D%9E%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E6%97%A0%E6%84%9F%E7%9F%A5%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/>继续阅读</a></div>
   </div>
   
   
   
</section>

<section class="post-comments">
  
    <div class="ds-thread" data-thread-key="/2016/10/%E5%88%9D%E6%8E%A2Runtime/" data-title="初探Runtime - isa & Class" data-url="http://localhost:4000/2016/10/%E5%88%9D%E6%8E%A2Runtime/"></div>
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"smallfan"};
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://smallfan.net">@Ford</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题。 - &copy; 2016-2017</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
